# -*- coding: utf-8 -*-
"""Lab_Proj_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BHLCcXkiLS6fKY06GTHdZBlQfRKxLK4h
"""

#@title Colab setup
import os, sys, subprocess
if "google.colab" in sys.modules:
  cmd = "pip install --upgrade biocircuits bokeh-catplot watermark blackcellmagic intersect"
  process = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  stdout, stderr = process.communicate()
# ------

# Libraries to solve the ODEs
import scipy.integrate
import biocircuits

# Libraries for mathematical analysis
import numpy as np
from intersect import intersection
import sympy as sym
import pylab as pl

# Libraries to visualize our results
import bokeh.io
import bokeh.plotting
import bokeh.palettes
from bokeh.models import LinearColorMapper, ColorBar
from bokeh.models import Range1d
from bokeh.io import export_svgs
import colorcet

interactive_python_plots = True
notebook_url = "localhost:8888"


bokeh.io.output_notebook()

# We need to define the system of ODEs that we want to solve
def red(x0,t,phi,delta,rho, beta, alpha, theta, k, a, d, n, K):
  x,y,z,u_1,u_2, c = x0
  f_z = (alpha * (z**n))/(K**n + z**n)
  h1_y = (alpha * (K**n))/(K**n + y**n)
  h2_y = (rho * (K**n))/(K**n + y**n)
  h3_y = (theta * (K**n))/(K**n + y**n)


  return(
      [
          h2_y - phi * x,
          f_z - delta * y + beta * u_1,
          h1_y - delta * z,
          k * x - phi*u_1 - a * u_1 * u_2 + d * c,
          h3_y - phi * u_2 - a * u_1 * u_2 + d * c,
          a * u_1 * u_2 - d * c - phi*c
      ]
  )

p = bokeh.plotting.figure(width=325*2, height=275,
                          x_range=Range1d(0, 100),
                          x_axis_label='Time (hours)',
                          y_axis_label='Concentration (uM)')


# Initial conditions for the first simulation
x01 = np.array([1, 0, 0, 1, 1, 1])

# Model parameters
phi = 1
delta =1
rho = 1
beta = 5
alpha = 1
theta = 2
k = 2
a = 1000
d = 1
n = 3
K=1
args = (phi,delta,rho,beta,alpha,theta,k,a,d,n,K)

# Simulation time
t = np.linspace(0, 300, 2000)

# Solve ODEs using scipy.integrate.odeint
x1 = scipy.integrate.odeint(red, x01, t, args=args)
x1 = x1.transpose()

# Plot the dynamics

#p.line(t, x1[0, :], color='orange', line_width=3, legend_label='X')

p.line(t, x1[1, :], color='black', line_width=3, legend_label='Y')
p.line(t, x1[2, :], color='gray', line_width=3, legend_label='Z')
# p.line(t, x1[3, :], color='red', line_width=3, legend_label='u_1')
# p.line(t, x1[4, :], color='blue', line_width=3, legend_label='u_2')


p.legend.location = 'top_left'

# Display the figure
bokeh.io.show(p)

# We need to define the system of ODEs that we want to solve
def blue(x0,t,phi,delta,rho, beta, alpha, theta, k, a, d, n, K):
  x,y,z,u_1,u_2, c = x0
  f_z = (alpha * (z**n))/(K**n + z**n)
  h1_y = (alpha * (K**n))/(K**n + y**n)
  h2_y = (rho * (z**n))/(K**n + z**n)
  h3_y = (theta * (z**n))/(K**n + z**n)


  return(
      [
          h2_y - phi * x,
          f_z - delta * y ,
          h1_y - delta * z + beta * u_1,
          k * x - phi*u_1 - a * u_1 * u_2 + d * c,
          h3_y - phi * u_2 - a * u_1 * u_2 + d * c,
          a * u_1 * u_2 - d * c - phi*c
      ]
  )

p = bokeh.plotting.figure(width=325*2, height=275,
                          x_range=Range1d(0, 100),
                          x_axis_label='Time (hours)',
                          y_axis_label='Concentration (uM)')


# Initial conditions for the first simulation
x01 = np.array([0, 0, 0, 0, 0, 0])

# Model parameters
phi = 1
delta = 1
rho = 1
beta = 5
alpha = 1
theta = 2
k = 2
a = 1000
d = 1
n = 3
K=1
args = (phi,delta,rho,beta,alpha,theta,k,a,d,n,K)

# Simulation time
t = np.linspace(0, 300, 2000)

# Solve ODEs using scipy.integrate.odeint
x1 = scipy.integrate.odeint(blue, x01, t, args=args)
x1 = x1.transpose()

# Plot the dynamics

#p.line(t, x1[0, :], color='orange', line_width=3, legend_label='X')

p.line(t, x1[1, :], color='black', line_width=3, legend_label='Y')
p.line(t, x1[2, :], color='gray', line_width=3, legend_label='Z')
# p.line(t, x1[3, :], color='red', line_width=3, legend_label='u_1')
# p.line(t, x1[4, :], color='blue', line_width=3, legend_label='u_2')


p.legend.location = 'top_left'

# Display the figure
bokeh.io.show(p)

# Definimos las ecuaciones de nullclines de cada especie
def null_u1(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K):
  u1 = (k * x + d * c) / (phi + a * u_2)
  return u1
def null_u2(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K):
  h3 = (theta * (K**n))/(K**n + y**n)
  u2 = (h3 + d * c) / (phi + a * u_1)
  return u2

def null_x(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K):
  h2 = (rho * (K**n))/(K**n + y**n)
  x = h2 / phi
  return x

def null_z(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K):
  z = ((delta * y * (k**n) - beta * u_1 * (k**n)) / (alpha + beta * u_1 - delta * y))**(1/n)
  return z
def null_y(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K):
  y = ((alpha * (k**n) - delta * z * (k**n)) / (delta * z)) ** (1/n)
  return y
def null_c(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K):
  c = (a * u_1 * u_2) / (d + phi)
  return c

# Definimos el entorno de visualización en bokeh
plots = []
plots.append(bokeh.plotting.figure(width=325, height=275,
                                   x_range=Range1d(0.01, 2.2),
                                   y_range=Range1d(0.01, 2.2),
                                   x_axis_label='Y',
                                   y_axis_label='Z'))

# Definimos las variables de estados
x = np.linspace(0.01, 3, 300)
y = np.linspace(0.01, 3, 300)
z = np.linspace(0.01, 3, 300)
c = np.linspace(0.01, 3, 300)
u_1 = np.linspace(0.01, 3, 300)
u_2 = np.linspace(0.01, 3, 300)


phi = 1
delta = 1
rho = 1
beta = 5
alpha = 1
theta = 2
k = 2
a = 1000
d = 1
n = 3
K=1

# Calculamos las expresiones del nullclines
nullx = null_x(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K)
nully = null_y(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K)
nullz = null_z(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K)
nullu1 = null_u1(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K)
nullu2 = null_u2(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K)
nullc = null_c(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K)

# Hallamos la intersección
#fixed_pts = intersection(nullz, z, nully, y)
fixed_pts = intersection(nully, y, nullz, z)
Y_i = fixed_pts[0]
Z_i = fixed_pts[1]

# Ploteamos
plots[0].line(nullz, z, line_width=3, color='black', alpha=0.75)
#cant see this line


plots[0].line(nully, y, line_width=3, color='black', alpha=0.75)
plots[0].scatter(Y_i, Z_i, size=8, fill_color='white', color='black', line_width=1)

# Simulación para observar el ciclo límite
t = np.linspace(0, 200, 800)
x_cond = np.random.rand(8)
y_cond = [2.2, 0.01, 2.2, 2.2, 0.01, 1.1, 0.01, 1.1]
z_cond = [2.2, 0.01, 2.2, 2.2, 0.01, 1.1, 0.01, 1.1]
u1_cond = [1.0] * 8
u2_cond = [1.0] * 8
c_cond = [0.5] * 8



for i, cX in enumerate(x_cond):
    x01 = np.array([cX, y_cond[i], z_cond[i],u1_cond[i], u2_cond[i], c_cond[i] ])
    args = (phi,delta,rho,beta,alpha,theta,k,a,d,n,K)
    sol = scipy.integrate.odeint(red, x01, t, args=args).T
    plots[0].line(sol[0, :], sol[1, :], line_width=3, color="orange", alpha=0.2)
    plots[0].scatter(cX, y_cond[i], size=4, color='orange', line_width=1)

plots[0].title.text = 'Phase Plane Red'

# Visualizamos
bokeh.io.show(bokeh.layouts.column(plots))

# Definimos las ecuaciones de nullclines de cada especie
def null_u1(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K):
  u1 = (k * x + d * c) / (phi + a * u_2)
  return u1
def null_u2(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K):
  h3 = (theta * (K**n))/(K**n + y**n)
  u2 = (h3 + d * c) / (phi + a * u_1)
  return u2

def null_x(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K):
  h2 = (rho * (K**n))/(K**n + y**n)
  x = h2 / phi
  return x

def null_z(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K):
  z = ((delta * y * (k**n) - beta * u_1 * (k**n)) / (alpha + beta * u_1 - delta * y))**(1/n)
  return z
def null_y(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K):
  y = ((alpha * (k**n) - delta * z * (k**n)) / (delta * z)) ** (1/n)
  return y
def null_c(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K):
  c = (a * u_1 * u_2) / (d + phi)
  return c

# Definimos el entorno de visualización en bokeh
plots = []
plots.append(bokeh.plotting.figure(width=325, height=275,
                                   x_range=Range1d(0, 2.2),
                                   y_range=Range1d(0, 2.2),
                                   x_axis_label='Z',
                                   y_axis_label='Y'))

# Definimos las variables de estados
x = np.linspace(0.01, 3, 300)
y = np.linspace(0.01, 3, 300)
z = np.linspace(0.01, 3, 300)
c = np.linspace(0.01, 3, 300)
u_1 = np.linspace(0.01, 3, 300)
u_2 = np.linspace(0.01, 3, 300)


phi = 1
delta = 1
rho = 1
beta = 5
alpha = 1
theta = 2
k = 2
a = 1000
d = 1
n = 3
K=1

# Calculamos las expresiones del nullclines
nullx = null_x(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K)
nully = null_y(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K)
nullz = null_z(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K)
nullu1 = null_u1(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K)
nullu2 = null_u2(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K)
nullc = null_c(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K)

# Hallamos la intersección
fixed_pts = intersection(nullz, z, nully, y)
X_i = fixed_pts[0]
Y_i = fixed_pts[1]

# Ploteamos
plots[0].line(nullz, z, line_width=3, color='black', alpha=0.75)
plots[0].line(nully, y, line_width=3, color='black', alpha=0.75)
plots[0].scatter(X_i, Y_i, size=8, fill_color='white', color='black', line_width=1)

# Simulación para observar el ciclo límite
t = np.linspace(0, 200, 800)
x_cond = [1.0] * 4
y_cond = np.random.rand(len(x_cond))
z_cond = [2.2, 0.01, 2.2, 2.2, 0.01, 1.1, 0.01, 1.1]
u1_cond = [1.0] * 4
u2_cond = [1.0] * 4
c_cond = [0.5] * 4



for i, cX in enumerate(x_cond):
    x01 = np.array([cX, y_cond[i], z_cond[i],u1_cond[i], u2_cond[i], c_cond[i] ])
    args = (phi,delta,rho,beta,alpha,theta,k,a,d,n,K)
    sol = scipy.integrate.odeint(red, x01, t, args=args).T
    plots[0].line(sol[0, :], sol[1, :], line_width=3, color="orange", alpha=0.2)
    plots[0].scatter(cX, y_cond[i], size=4, color='orange', line_width=1)

plots[0].title.text = 'Ciclo límite'

# Visualizamos
bokeh.io.show(bokeh.layouts.column(plots))

# Definimos las ecuaciones de nullclines de cada especie
def null_u1(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K):
  u1 = (k * x + d * c) / (phi + a * u_2)
  return u1
def null_u2(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K):
  h3 = (theta * (K**n))/(K**n + z**n)
  u2 = (h3 + d * c) / (phi + a * u_1)
  return u2

def null_x(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K):
  h2 = (rho * (K**n))/(K**n + z**n)
  x = h2 / phi
  return x

def null_z(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K):
  z = ((delta * y * (k**n)) / (alpha - delta * y))**(1/n)
  return z
def null_y(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K):
  y = ((alpha * (k**n) + beta * u_1 * (k**n) - delta * z * (k**n)) / (delta * z - beta * u_1)) ** (1/n)
  return y
def null_c(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K):
  c = (a * u_1 * u_2) / (d + phi)
  return c

# Definimos el entorno de visualización en bokeh
plots = []
plots.append(bokeh.plotting.figure(width=325, height=275,
                                   x_range=Range1d(.01, 2.2),
                                   y_range=Range1d(.01, 2.2),
                                   x_axis_label='Z',
                                   y_axis_label='Y'))

# Definimos las variables de estados
x = np.linspace(0.001, 3, 300)
y = np.linspace(0.001, 3, 300)
z = np.linspace(0.001, 3, 300)
c = np.linspace(0.001, 3, 300)
u_1 = np.linspace(0.001, 3, 300)
u_2 = np.linspace(0.001, 3, 300)


phi = 1
delta = 1
rho = 1
beta = 5
alpha = 1
theta = 2
k = 2
a = 1000
d = 1
n = 3
K=1

# Calculamos las expresiones del nullclines
nullx = null_x(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K)
nully = null_y(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K)
nullz = null_z(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K)
nullu1 = null_u1(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K)
nullu2 = null_u2(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K)
nullc = null_c(x,y,z,u_1,u_2, c,phi,delta,rho,beta,alpha,theta,k,a,d,n,K)

# Hallamos la intersección
fixed_pts = intersection(nullz, z, nully, y)
X_i = fixed_pts[0]
Y_i = fixed_pts[1]

# Ploteamos
plots[0].line(nullz, z, line_width=3, color='black', alpha=0.75)
plots[0].line(nully, y, line_width=3, color='black', alpha=0.75)
plots[0].scatter(X_i, Y_i, size=8, fill_color='white', color='black', line_width=1)

# Simulación para observar el ciclo límite
t = np.linspace(0, 200, 800)
x_cond = [1.0] * 4
y_cond = np.random.rand(len(x_cond))
z_cond = [2.2, 0.01, 2.2, 2.2, 0.01, 1.1, 0.01, 1.1]
u1_cond = [1.0] * 4
u2_cond = [1.0] * 4
c_cond = [0.5] * 4



for i, cX in enumerate(x_cond):
    x01 = np.array([cX, y_cond[i], z_cond[i],u1_cond[i], u2_cond[i], c_cond[i] ])
    args = (phi,delta,rho,beta,alpha,theta,k,a,d,n,K)
    sol = scipy.integrate.odeint(blue, x01, t, args=args).T
    plots[0].line(sol[0, :], sol[1, :], line_width=3, color="orange", alpha=0.2)
    plots[0].scatter(cX, y_cond[i], size=4, color='orange', line_width=1)

plots[0].title.text = 'Phase Plane Blue'

# Visualizamos
bokeh.io.show(bokeh.layouts.column(plots))

import numpy as np
import bokeh.plotting
import bokeh.layouts
from bokeh.models import Range1d
import scipy.integrate

# Define the red system of ODEs
def red(x0, t, phi, delta, rho, beta, alpha, theta, k, a, d, n, K):
    x, y, z, u_1, u_2, c = x0
    f_z = (alpha * (z ** n)) / (K ** n + z ** n)
    h1_y = (alpha * (K ** n)) / (K ** n + y ** n)
    h2_y = (rho * (K ** n)) / (K ** n + y ** n)
    h3_y = (theta * (K ** n)) / (K ** n + y ** n)

    return [
        h2_y - phi * x,
        f_z - delta * y + beta * u_1,
        h1_y - delta * z,
        k * x - phi * u_1 - a * u_1 * u_2 + d * c,
        h3_y - phi * u_2 - a * u_1 * u_2 + d * c,
        a * u_1 * u_2 - d * c - phi * c
    ]

# Parameters
phi = 1
delta = 1
rho = 1
beta = 5
alpha = 1
theta = 2
k = 2
a = 1000
d = 1
n = 3
K = 1
args = (phi, delta, rho, beta, alpha, theta, k, a, d, n, K)

# Nullcline functions (fixed u1 = 1 for projection)
def nullcline_y(Y, Z):
    f_z = (alpha * Z**n) / (K**n + Z**n)
    return f_z / delta

def nullcline_z(Y, u1):
    h1_y = (alpha * (K**n)) / (K**n + Y**n)
    return (h1_y + beta * u1) / delta

# Create Bokeh figure
plot = bokeh.plotting.figure(width=325, height=275,
                             x_range=Range1d(0, 3),
                             y_range=Range1d(0, 3),
                             x_axis_label='Z',
                             y_axis_label='Y',
                             title='Ciclo límite (Red System)')

# Generate meshgrid for nullclines
z_vals = np.linspace(0, 3, 300)
y_vals = np.linspace(0, 3, 300)
Z, Y = np.meshgrid(z_vals, y_vals)
u1_val = 1.0

# Evaluate nullclines
dy_dt = nullcline_y(Y, Z) - Y
dz_dt = nullcline_z(Y, u1_val) - Z

# Show nullclines as binary masks
dy_zero = np.abs(dy_dt) < 0.01
dz_zero = np.abs(dz_dt) < 0.01

#plot.image(image=[dy_zero.astype(int)], x=0, y=0, dw=3, dh=3, palette="Blues256")
#plot.image(image=[dz_zero.astype(int)], x=0, y=0, dw=3, dh=3, palette="Reds256")



# Simulate trajectories and overlay
t = np.linspace(0, 300, 1000)
x_cond = [0.5, 2.5, 1.5, 2.2]
y_cond = [2.2, 0.5, 2.0, 1.1]
z_cond = [2.0, 0.1, 2.5, 1.1]
u1_cond = [1.0] * 4
u2_cond = [1.0] * 4
c_cond = [0.5] * 4

for i in range(len(x_cond)):
    x0 = [x_cond[i], y_cond[i], z_cond[i], u1_cond[i], u2_cond[i], c_cond[i]]
    sol = scipy.integrate.odeint(red, x0, t, args=args)
    plot.line(sol[:, 2], sol[:, 1], line_width=2, color='orange', alpha=0.6)  # z vs y
    plot.scatter([z_cond[i]], [y_cond[i]], size=5, color='black')

# Show the plot
bokeh.io.show(bokeh.layouts.column(plot))

from bokeh.models import Legend
from bokeh.layouts import row, column

colors = bokeh.palettes.Oranges8[::-1]
plots = []
legends = []

# Prepare figure containers and empty legend entries
for i in range(3):
    fig = bokeh.plotting.figure(width=360, height=225,
                                x_range=Range1d(0, 20),
                                x_axis_label='Time (hours)',
                                y_axis_label='[X]')
    plots.append(fig)
    legends.append([])

# --- Varying α (production rate) ---
x01 = np.array([0, 0, 0, 0, 0, 0])
alpha_space = np.array([0.5, 1, 1.5, 2])


phi = 1
delta = 1
rho = 1
beta = 5

theta = 2
k = 2
a = 1000
d = 1
n = 3
K=1
t = np.linspace(0, 40, 800)

for i, alpha in enumerate(alpha_space):
    args = (phi, delta, rho, beta, alpha, theta, k, a, d, n, K)
    x1 = scipy.integrate.odeint(red, x01, t, args=args).T
    line = plots[0].line(t, x1[0, :], color=colors[i+1], line_width=3)
    legends[0].append((f"α = {alpha}", [line]))

plots[0].title.text = 'Varying α'

# --- Varying n (Hill coefficient) ---
x01 = np.array([0, 0, 0, 0, 0, 0])
n_space = np.array([1.0, 2.0, 4.0, 8])


phi = 1
delta = 1
rho = 1
beta = 5
alpha = 1
theta = 2
k = 2
a = 1000
d = 1

K=1
t = np.linspace(0, 40, 800)

for i, n in enumerate(n_space):
    args = (phi, delta, rho, beta, alpha, theta, k, a, d, n, K)
    x1 = scipy.integrate.odeint(red, x01, t, args=args).T
    line = plots[1].line(t, x1[0, :], color=colors[i+1], line_width=3)
    legends[1].append((f"n = {n}", [line]))

plots[1].title.text = 'Varying n'

# --- Varying δ (degradation rate) ---
x01 = np.array([0, 0, 0, 0, 0, 0])
d_space = np.array([0.1, 0.5, 1.5, 2])


phi = 1

rho = 1
beta = 5
alpha = 1
theta = 2
k = 2
a = 1000
d = 1
n = 3
K=1
t = np.linspace(0, 40, 800)

for i, delta in enumerate(d_space):
    args = (phi, delta, rho, beta, alpha, theta, k, a, d, n, K)
    x1 = scipy.integrate.odeint(red, x01, t, args=args).T
    line = plots[2].line(t, x1[0, :], color=colors[i+1], line_width=3)
    legends[2].append((f"δ = {delta}", [line]))

plots[2].title.text = 'Varying δ'

# --- Add external legends to the right ---
for i in range(3):
    legend = Legend(items=legends[i], location="center")
    legend.background_fill_alpha = 0.0
    plots[i].add_layout(legend, 'right')

bokeh.io.show(row(plots))